import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

// 좌표 저장하는 클래스
class xypos{
    int x, y;

    public xypos(int x, int y){
        this.x = x;
        this.y = y;
    }
}

// 레이아웃 클래스
public class CGPanel extends JPanel{
    final int pix = 10;
    final int numX = 30;
    final int numY = 30;
    final int sizeX = numX * pix;
    final int sizeY = numY * pix;

    CGPad cgpad;

    MidPointEllipse MEA_Algorithm;
    DDA DDA_Algorithm;
    Bresenham BSH_Algorithm;
    SamGak SAM_Algorithm;
    matrix_move Matrix_move_Algorithm;

    CGPanel(){
        cgpad = new CGPad();
        
        setLayout(new FlowLayout());
        add(cgpad);
        add(new CGButton()); // control이 들어가야 함
    }

    // 모눈 종이 클래스
    class CGPad extends JPanel{
        CGPad(){
            setPreferredSize(new Dimension((sizeX + 1) * 2, (sizeY + 1) * 2));
        }

        public void paintComponent(Graphics g){
            super.paintComponent(g);

            Graphics2D g2 = (Graphics2D)g;
            g2.translate(sizeX,sizeY);
            g2.setColor(Color.gray);
            g2.setStroke(new BasicStroke(1));

            for(int i=-sizeY; i<=sizeY; i+=pix){
                g2.drawLine(-sizeX, i, sizeX, i);
            }
            for(int i=-sizeX; i<=sizeX; i+=pix){
                g2.drawLine(i, -sizeY, i, sizeY);
            }

            g2.setColor(Color.BLACK);
            g2.setStroke(new BasicStroke(2));
            g2.drawLine(-sizeX, 0, sizeX, 0);
            g2.drawLine(0, -sizeY, 0, sizeY);

            g.setColor(Color.black);
            if(MEA_Algorithm != null){

                for(xypos point : MEA_Algorithm.array){
                    boolean inpad = (point.x <= numX && point.x >= -numX && point.y <= numY && point.y >= -numY);

                    if(inpad){
                        g.fillRect(point.x * pix, -(point.y + 1) * pix, pix, pix);
                    }
                }
            }

            if(DDA_Algorithm != null){
                for(xypos point : DDA_Algorithm.array){
                    boolean inpad = (point.x <= numX && point.x >= -numX && point.y <= numY && point.y >= -numY);

                    if(inpad){
                        g.fillRect(point.x * pix, -(point.y + 1) * pix, pix, pix);
                    }
                }
            }

            if(BSH_Algorithm != null){
                for(xypos point : BSH_Algorithm.array){
                    boolean inpad = (point.x <= numX && point.x >= -numX && point.y <= numY && point.y >= -numY);

                    if(inpad){
                        g.fillRect(point.x * pix, -(point.y + 1) * pix, pix, pix);
                    }
                }
            }

            if(SAM_Algorithm != null){
                for(xypos point : SAM_Algorithm.array){
                    boolean inpad = (point.x <= numX && point.x >= -numX && point.y <= numY && point.y >= -numY);

                    if(inpad){
                        g.fillRect(point.x * pix, -(point.y + 1) * pix, pix, pix);
                    }
                }
            }

            if(Matrix_move_Algorithm != null){
                for(xypos point : Matrix_move_Algorithm.array){
                    boolean inpad = (point.x <= numX && point.x >= -numX && point.y <= numY && point.y >= -numY);

                    if(inpad){
                        g.fillRect(point.x * pix, -(point.y + 1) * pix, pix, pix);
                    }
                }
            }
        }
    }

    class CGButton extends JPanel{
        CGButton(){
            setPreferredSize(new Dimension(800, 600));
            // row, cols, gaps -> 칸이 적을경우 rows를 우선적으로 지킴
            setLayout(new GridLayout(8, 8, 2, 2));
            
            System.out.println("CGButton() 체크");

            MEA_Buttons();
            DDA_Buttons();
            BSH_Buttons();
            MOVE_Buttons();
            ZIZO_Buttons();
            SamGak_Buttons();
            Matrix_move_Buttons();
            Matrix_scale_Buttons();
            // Matrix_rotate_Buttons();
            // Matrix_bock_Buttons();
        }

        public void Matrix_scale_Buttons(){
            JLabel s_point = new JLabel("S Point");
            JTextField sx = new JTextField();
            JTextField sy = new JTextField();
            JLabel f_point = new JLabel("F Point");
            JTextField xf = new JTextField();
            JTextField yf = new JTextField();
            JButton algButton = new JButton("Mat Scale");
            JButton clearButton = new JButton("Clear");

            add(s_point);
            add(sx);
            add(sy);
            add(f_point);
            add(xf);
            add(yf);
            add(algButton);
            add(clearButton);

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(sx.getText());
                int int_y1 = Integer.parseInt(sy.getText());
                int int_x2 = Integer.parseInt(xf.getText());
                int int_y2 = Integer.parseInt(yf.getText());

                SAM_Algorithm.scale(int_x1, int_y1, int_x2, int_y2);
                cgpad.repaint();
            });

            clearButton.addActionListener(e ->{
                sx.setText("");
                sy.setText("");
                xf.setText("");
                yf.setText("");

                Matrix_move_Algorithm.array.clear();
                cgpad.repaint();
            });
        }

        public void Matrix_move_Buttons(){
            JLabel x1_label = new JLabel("x");
            JTextField x1 = new JTextField();
            JLabel y1_label = new JLabel("y");
            JTextField y1 = new JTextField();
            JButton algButton = new JButton("Mat_Move");
            JButton clearButton = new JButton("Clear");

            add(x1_label);
            add(x1);
            add(y1_label);
            add(y1);
            add(new JLabel());
            add(new JLabel());
            add(algButton);
            add(clearButton);

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(x1.getText());
                int int_y1 = Integer.parseInt(y1.getText());

                SAM_Algorithm.move(int_x1, int_y1);
                cgpad.repaint();
            });

            clearButton.addActionListener(e ->{
                x1.setText("");
                y1.setText("");

                Matrix_move_Algorithm.array.clear();
                cgpad.repaint();
            });
        }

        public void SamGak_Buttons(){
            JTextField x1 = new JTextField();
            JTextField y1 = new JTextField();
            JTextField x2 = new JTextField();
            JTextField y2 = new JTextField();
            JTextField x3 = new JTextField();
            JTextField y3 = new JTextField();
            JButton algButton = new JButton("SamGak");
            JButton clearButton = new JButton("Clear");

            add(x1);
            add(y1);
            add(x2);
            add(y2);
            add(x3);
            add(y3);
            add(algButton);
            add(clearButton);

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(x1.getText());
                int int_y1 = Integer.parseInt(y1.getText());
                int int_x2 = Integer.parseInt(x2.getText());
                int int_y2 = Integer.parseInt(y2.getText());
                int int_x3 = Integer.parseInt(x3.getText());
                int int_y3 = Integer.parseInt(y3.getText());

                SAM_Algorithm = new SamGak(int_x1, int_y1, int_x2, int_y2, int_x3, int_y3);
                cgpad.repaint();
            });

            clearButton.addActionListener(e ->{
                x1.setText("");
                y1.setText("");
                x2.setText("");
                y2.setText("");
                x3.setText("");
                y3.setText("");

                SAM_Algorithm.array.clear();
                cgpad.repaint();
            });
        }

        public void ZIZO_Buttons(){
            JLabel sizes = new JLabel("Size");
            JTextField size = new JTextField();
            JButton algButton = new JButton("Z In/Out");

            add(sizes);
            add(size);
            add(new JLabel());
            add(new JLabel());
            add(new JLabel());
            add(new JLabel());
            add(algButton);
            add(new JLabel());

            algButton.addActionListener(e ->{
                int Dradian = Integer.parseInt(size.getText());

                if(MEA_Algorithm != null){
                    MEA_Algorithm = new MidPointEllipse(MEA_Algorithm.GetPoint_x(), MEA_Algorithm.GetPoint_y(), MEA_Algorithm.GetRadian() + Dradian);
                }

                cgpad.repaint();
            });
        }

        public void MOVE_Buttons(){
            // 확대, 축소, 이동 중 일단 이동 작성
            JLabel point1 = new JLabel("Move Point");
            JTextField x1 = new JTextField();
            JTextField y1 = new JTextField();
            JButton algButton = new JButton("Move");

            add(point1);
            add(x1);
            add(y1);
            add(new JLabel());
            add(new JLabel());
            add(new JLabel());
            add(algButton);
            add(new JLabel());

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(x1.getText());
                int int_y1 = Integer.parseInt(y1.getText());

                if(MEA_Algorithm != null && MEA_Algorithm.array.size() != 0){
                    MEA_Algorithm.SetPoint_x(int_x1);
                    MEA_Algorithm.SetPoint_y(int_y1);
                    MEA_Algorithm.move(int_x1, int_y1);
                }

                if(SAM_Algorithm != null && SAM_Algorithm.array.size() != 0){
                    SAM_Algorithm.move(int_x1, int_y1);
                }
                cgpad.repaint();
            });
        }

        public void BSH_Buttons(){
            JTextField x1 = new JTextField();
            JTextField y1 = new JTextField();
            JTextField x2 = new JTextField();
            JTextField y2 = new JTextField();
            JLabel point1 = new JLabel("Point1");
            JLabel point2 = new JLabel("Point2");
            JButton algButton = new JButton("Breseham");
            JButton clearButton = new JButton("Clear");

            add(point1);
            add(x1);
            add(y1);
            add(point2);
            add(x2);
            add(y2);
            add(algButton);
            add(clearButton);

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(x1.getText());
                int int_y1 = Integer.parseInt(y1.getText());
                int int_x2 = Integer.parseInt(x2.getText());
                int int_y2 = Integer.parseInt(y2.getText());

                BSH_Algorithm = new Bresenham(int_x1, int_y1, int_x2, int_y2);
                cgpad.repaint();
            });

            clearButton.addActionListener(e ->{
                x1.setText("");
                y1.setText("");
                x2.setText("");
                y2.setText("");

                BSH_Algorithm.array.clear();
                cgpad.repaint();
            });
        }

        public void DDA_Buttons(){
            JTextField x1 = new JTextField();
            JTextField y1 = new JTextField();
            JTextField x2 = new JTextField();
            JTextField y2 = new JTextField();
            JLabel point1 = new JLabel("Point1");
            JLabel point2 = new JLabel("Point2");
            JButton algButton = new JButton("DDA");
            JButton clearButton = new JButton("Clear");

            add(point1);
            add(x1);
            add(y1);
            add(point2);
            add(x2);
            add(y2);
            add(algButton);
            add(clearButton);

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(x1.getText());
                int int_y1 = Integer.parseInt(y1.getText());
                int int_x2 = Integer.parseInt(x2.getText());
                int int_y2 = Integer.parseInt(y2.getText());

                DDA_Algorithm = new DDA(int_x1, int_y1, int_x2, int_y2);
                cgpad.repaint();
            });

            clearButton.addActionListener(e ->{
                x1.setText("");
                y1.setText("");
                x2.setText("");
                y2.setText("");

                DDA_Algorithm.array.clear();
                cgpad.repaint();
            });
        }

        public void MEA_Buttons(){
            JTextField x1 = new JTextField();
            JTextField y1 = new JTextField();
            JTextField radian = new JTextField();
            JButton algButton = new JButton("MEA");
            JButton clearButton = new JButton("Clear");
            JLabel point1 = new JLabel("Point1");
            JLabel radian1 = new JLabel("radian");

            add(point1);
            add(x1);
            add(y1);
            add(radian1);
            add(radian);
            add(new JLabel());
            add(algButton);
            add(clearButton);

            algButton.addActionListener(e ->{
                int int_x1 = Integer.parseInt(x1.getText());
                int int_y1 = Integer.parseInt(y1.getText());
                int int_radian = Integer.parseInt(radian.getText());

                System.out.println("버튼 로그 - int 파싱 여부 확인");
                System.out.println(int_x1);
                System.out.println(int_y1);
                System.out.println(int_radian);
                System.out.println("버튼 로고 끝");

                MEA_Algorithm = new MidPointEllipse(int_x1, int_y1, int_radian);
                cgpad.repaint();
            });

            clearButton.addActionListener(e ->{
                x1.setText("");
                y1.setText("");
                radian.setText("");

                MEA_Algorithm.array.clear();
                cgpad.repaint();
            });
        }
    }
}

// 모든 알고리즘이 출력하는 부분
class Algorithm extends CGPanel{
    public ArrayList<xypos> array = new ArrayList<>();

    public Algorithm(){
    }

    public void move(int dx, int dy){
        ArrayList<xypos> move_array = new ArrayList<>();
        for(xypos p : this.array){
            int[][] tmp = {{p.x,p.y,1}};
            int[][] mov = {{1,0,0},{0,1,0},{dx,dy,1}};
            int [][] tmpRes = matMul(tmp, mov);

            move_array.add(0, new xypos(tmpRes[0][0], tmpRes[0][1]));
        }
        array = move_array;
    }

    public void scale(int sx, int sy, int xf, int yf){
        ArrayList<xypos> move_array = new ArrayList<>();

        for(xypos p : this.array){
            int[][] tmp = {{p.x,p.y,1}};
            int[][] mov = {
                {1,0,0},
                {0,1,0},
                {(1-sx) * xf, (1-sy) * yf, 1}
            };
            int [][] tmpRes = matMul(tmp, mov);

            move_array.add(0, new xypos(tmpRes[0][0], tmpRes[0][1]));
        }
        array = move_array;
    }

    public int[][] matMul(int[][] matrix1, int[][] matrix2) { //행렬 곱셈 함수
        int row1 = matrix1.length; // 첫 번째 행렬의 행 길이
        int col1 = matrix1[0].length; // 첫 번째 행렬의 열 길이
        int row2 = matrix2.length; // 두 번째 행렬의 행 길이
        int col2 = matrix2[0].length; // 두 번째 행렬의 열 길이
 
        // 두 행렬이 곱셈이 가능한 크기인지 검사
        if (col1 != row2) {
            throw new IllegalArgumentException("두 행렬의 크기가 곱셈에 맞지 않습니다.");
        }
 
        int[][] result = new int[row1][col2]; // 결과를 저장할 2차원 배열
 
        // 곱셈 연산
        for (int i = 0; i < row1; i++) {
            for (int j = 0; j < col2; j++) {
                for (int k = 0; k < col1; k++) {
                    result[i][j] += matrix1[i][k] * matrix2[k][j];
                }
            }
        }
        return result;
    } 
    
    public void print_array(Graphics g){
        g.setColor(Color.black);

        for(xypos point : this.array){
            boolean inpad = (point.x <= super.numX && point.x >= -super.numX && point.y <= super.numY && point.y >= -super.numY);

            if(inpad){
                System.out.print("그려짐");
                g.fillRect(point.x * super.pix, -(point.y + 1) * super.pix, super.pix, super.pix);
            }
        }
    }
}

class SamGak extends Algorithm{
    SamGak(int xa, int ya, int xb, int yb, int xc, int yc){
        DDA(xa, ya, xb, yb);
        DDA(xb, yb, xc, yc);
        DDA(xc, yc, xa, ya);
    }

    public void DDA(int xa, int ya, int xb, int yb) {
        int dx = xb - xa;
        int dy = yb - ya;
        int steps;
        float x = xa;
        float y = ya;
        float xIncrement, yIncrement;

        System.out.println("dx, dy value: ");
        System.out.println(dx);
        System.out.println(dy);
        System.out.println("dx, dy value end");

        if(Math.abs(dx) > Math.abs(dy)){
            steps = Math.abs(dx);
        }
        else{
            steps = Math.abs(dy);
        }

        xIncrement = dx / (float)steps;
        yIncrement = dy / (float)steps;

        super.array.add(0, new xypos(round(x), round(y)));

        System.out.print("steps value: ");
        System.out.println(steps);

        for(int k=0; k<steps; k++){
            x += xIncrement;
            y += yIncrement;
            super.array.add(0, new xypos(round(x), round(y)));
        }
    }

    public int round(float a){
        return (int)(a + 0.5);
    }
}

class DDA extends Algorithm{
    public DDA(int xa, int ya, int xb, int yb) {
        int dx = xb - xa;
        int dy = yb - ya;
        int steps;
        float x = xa;
        float y = ya;
        float xIncrement, yIncrement;

        System.out.println("dx, dy value: ");
        System.out.println(dx);
        System.out.println(dy);
        System.out.println("dx, dy value end");

        if(Math.abs(dx) > Math.abs(dy)){
            steps = Math.abs(dx);
        }
        else{
            steps = Math.abs(dy);
        }

        xIncrement = dx / (float)steps;
        yIncrement = dy / (float)steps;

        super.array.add(0, new xypos(round(x), round(y)));

        System.out.print("steps value: ");
        System.out.println(steps);

        for(int k=0; k<steps; k++){
            x += xIncrement;
            y += yIncrement;
            super.array.add(0, new xypos(round(x), round(y)));
        }
    }

    public int round(float a){
        return (int)(a + 0.5);
    }
}

class Bresenham extends Algorithm{
    // 브레센헴은 애초에 기울기가 1보다 작아야한다.
    public Bresenham(int xa, int ya, int xb, int yb){
        boolean change;

        if(Math.abs(xb - xa) < Math.abs(yb - ya)){
            change = true;
            int temp = xa;
            xa = ya;
            ya = temp;

            temp = xb;
            xb = yb;
            yb = temp;
        }
        else{
            change = false;
        }

        int dx = Math.abs(xa - xb);
        int dy = Math.abs(ya - yb);
        int p = 2 * dy - dx;
        int twoDy = 2 * dy;
        int twoDyDx = 2 * (dy - dx);
        int x, y, xEnd, Dy;

        System.out.println("twoDy, twoDyDx values");
        System.out.println(twoDy);
        System.out.println(twoDyDx);
        System.out.println("twoDy, twoDyDx values end");

        if(xa > xb){
            x = xb;
            y = yb;
            xEnd = xa;
        }
        else{
            x = xa;
            y = ya;
            xEnd = xb;
        }

        if(change){
            super.array.add(0, new xypos(y, x));
        }
        else{
            super.array.add(0, new xypos(x, y));
        }

        if(ya <= yb){
            Dy = 1;
        }
        else{
            Dy = -1;
        }

        while(x < xEnd){
            x += 1;

            // 증가 그래프, 감소 그래프에 대한 판단이 없어 추가함
            if(p < 0){
                p += twoDy;
            }
            else{
                y += Dy;
                p += twoDyDx;
            }
            System.out.println("Breseham cal values");
            System.out.println(x);
            System.out.println(y);
            System.out.println(p);
            System.out.println("Breseham cal values end");

            if(change){
                super.array.add(0, new xypos(y, x));
            }
            else{
                super.array.add(0, new xypos(x, y));
            }
        }
    }
}

class MidPointEllipse extends Algorithm{
    int x, y, p;
    int point_x, point_y, radian;
    
    public MidPointEllipse(int x1, int y1, int radian) {
        this.point_x = x1;
        this.point_y = y1;
        this.radian = radian;

        this.x = 0;
        this.y = radian;
        this.p = 1 - radian;
        
        // 좌표 세이브
        CirclePlotPoints(x1, y1, x, y);

        while(x < y){
            x++;

            if(p < 0){
                p += 2 * x + 1;
            }
            else{
                y--;
                p += 2 * (x - y) + 1;
            }
            // 좌표 세이브
            CirclePlotPoints(x1, y1, x, y);
        }
    }

    public int GetPoint_x(){
        return this.point_x;
    }

    public int GetPoint_y(){
        return this.point_y;
    }

    public int GetRadian(){
        return this.radian;
    }

    public void SetPoint_x(int x){
        this.point_x = x;
    }

    public void SetPoint_y(int y){
        this.point_y = y;
    }

    void CirclePlotPoints(int xCenter, int yCenter, int x, int y){
        super.array.add(0, new xypos(xCenter + x, yCenter + y));
        super.array.add(0, new xypos(xCenter - x, yCenter + y));
        super.array.add(0, new xypos(xCenter + x, yCenter - y));
        super.array.add(0, new xypos(xCenter - x, yCenter - y));
        super.array.add(0, new xypos(xCenter + y, yCenter + x));
        super.array.add(0, new xypos(xCenter - y, yCenter + x));
        super.array.add(0, new xypos(xCenter + y, yCenter - x));
        super.array.add(0, new xypos(xCenter - y, yCenter - x));
    }
}

class matrix_move extends Algorithm{
    public matrix_move(int a, int b){
        ArrayList<xypos> move_array = new ArrayList<>();

        System.out.println("super.array");
        System.out.println(super.array);
        for(xypos point : SAM_Algorithm.array){
            xypos res = matMove(point ,1 ,0,a,0,1,b);
            System.out.println("res check");
            System.out.println(point);
            System.out.println(res);
            System.out.println("check end");
            move_array.add(0, res);
        }
        super.array = move_array;
    }

    public int[][] matMul(int[][] matrix1, int[][] matrix2) { //행렬 곱셈 함수
        int row1 = matrix1.length; // 첫 번째 행렬의 행 길이
        int col1 = matrix1[0].length; // 첫 번째 행렬의 열 길이
        int row2 = matrix2.length; // 두 번째 행렬의 행 길이
        int col2 = matrix2[0].length; // 두 번째 행렬의 열 길이
 
        // 두 행렬이 곱셈이 가능한 크기인지 검사
        if (col1 != row2) {
            throw new IllegalArgumentException("두 행렬의 크기가 곱셈에 맞지 않습니다.");
        }
 
        int[][] result = new int[row1][col2]; // 결과를 저장할 2차원 배열
 
        // 곱셈 연산
        for (int i = 0; i < row1; i++) {
            for (int j = 0; j < col2; j++) {
                for (int k = 0; k < col1; k++) {
                    result[i][j] += matrix1[i][k] * matrix2[k][j];
                }
            }
        }
        return result;
    } 

    public xypos matMove(xypos p, int a, int b, int c, int d, int e, int f) //행렬을 이용한 좌표이동
    {
       xypos result = new xypos(0,0); //결과를 할당할 xypos 변수
       int[][] tmp = {{p.x,p.y,1}};
       int[][] mov = {{a,d,0},{b,e,0},{c,f,1}};
       
       int[][] tmpRes = matMul(tmp,mov); //행렬 곱셈 함수 호출하고 2차원 배열 결과로 할당받음.
       //결과로 받은 행렬에서 x,y값 뽑아서 각각 할당
       result.x = tmpRes[0][0];
       result.y = tmpRes[0][1];
       //xypos 객체 result를 return.
       return result;
    }
 
}

// class matrix{
//     public matrix(int[][] matrix){    
//     }

//     public int[][] matrix_cal(int[][] matrix1, int[][] matrix2){
//         int [][] result = new int[3][3];

//         for (int i = 0; i < 3; i++) {
//             for (int j = 0; j < 3; j++) {
//                 for (int k = 0; k < 3; k++) {
//                     result[i][j] += matrix1[i][k] * matrix2[k][j];
//                 }
//             }
//         }

//         return result;
//     }
// }

// public xypos matMove(xypos p,int tx, int ty) //행렬을 이용한 좌표이동
//    {
//       xypos result = new xypos(0,0); //결과를 할당할 xypos 변수
//       int[][] tmp = {{p.x,p.y,1}};
//       int[][] mov = {{1,0,0},{0,1,0},{tx,ty,1}};
      
//       int[][] tmpRes = matMul(tmp,mov); //행렬 곱셈 함수 호출하고 2차원 배열 결과로 할당받음.
//       //결과로 받은 행렬에서 x,y값 뽑아서 각각 할당
//       result.x = tmpRes[0][0];
//       result.y = tmpRes[0][1];
//       //xypos 객체 result를 return.
//       return result;
//    }
